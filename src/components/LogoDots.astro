---
/**
 * Props:
 *  - src: ruta del logo (SVG o PNG en /public)
 *  - density: separación de puntos (6=+denso, 10=-denso)
 *  - starChance: probabilidad de "estrellitas"
 */
 const { src = "/logo.svg", density = 10, starChance = 0.02 } = Astro.props;
---
<div class="relative w-full h-full">
  <canvas id="logoDots" class="w-full h-full block"></canvas>
</div>

<script define:vars={{ src, density, starChance }}>
  const SRC = src;
  const DENSITY = Number(density) || 8;
  const STAR_CHANCE = Number(starChance) || 0.002;

  const canvas = document.getElementById("logoDots");
  const ctx = canvas.getContext("2d", { willReadFrequently: true });
  const DPR = Math.min(window.devicePixelRatio || 1, 2);

  // Variables para la animación
  let animationProgress = 0;
  let animationId = null;
  let dots = [];
  let centerX = 0, centerY = 0;

  function resize() {
    const { width, height } = canvas.getBoundingClientRect();
    canvas.width = Math.floor(width * DPR);
    canvas.height = Math.floor(height * DPR);
    ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
  }

  function loadImage(url) {
    return new Promise((res, rej) => {
      const img = new Image();
      img.crossOrigin = "anonymous";
      img.onload = () => res(img);
      img.onerror = rej;
      img.src = url;
    });
  }

  function drawLogoToBuffer(img) {
    const w = canvas.width / DPR;
    const h = canvas.height / DPR;

    const scale = Math.min((w * 0.9) / img.width, (h * 0.9) / img.height);
    const dw = img.width * scale;
    const dh = img.height * scale;
    const dx = (w - dw) / 2;
    const dy = (h - dh) / 2;

    const off = document.createElement("canvas");
    off.width = Math.ceil(w);
    off.height = Math.ceil(h);
    const octx = off.getContext("2d");
    octx.clearRect(0, 0, off.width, off.height);
    octx.drawImage(img, dx, dy, dw, dh);
    return octx.getImageData(0, 0, off.width, off.height);
  }

  function generateDots(imgData) {
    const w = imgData.width, h = imgData.height, data = imgData.data;
    const step = DENSITY;
    const rnd = (s=1)=> (Math.random()*2-1) * s;
    
    centerX = w / 2;
    centerY = h / 2;
    
    dots = [];

    for (let y = 0; y < h; y += step) {
      for (let x = 0; x < w; x += step) {
        const i = (y * w + x) * 4;
        const a = data[i+3];
        if (a < 10) continue;

        const r = data[i], g = data[i+1], b = data[i+2];
        const lum = (0.2126*r + 0.7152*g + 0.0722*b) / 255;
        if (lum < 0.12) continue;

        // Calcular distancia desde el centro
        const distance = Math.sqrt((x - centerX) ** 2 + (y - centerY) ** 2);
        
        // degradé diagonal (izq-abajo → der-arriba) - más rosado y brilloso
        const t = Math.min(1, Math.max(0, (x + (h - y)) / (w + h)));
        const R = Math.round(220 + 35 * t);
        const G = Math.round(120 + 30 * (1 - t));
        const B = Math.round(180 + 40 * t);
        const alpha = 0.6 + 0.4 * lum;

        const jx = rnd(1.3), jy = rnd(1.3);
        const px = x + jx, py = y + jy;

        dots.push({
          x: px,
          y: py,
          color: `rgba(${R},${G},${B},${alpha})`,
          distance: distance,
          isStar: Math.random() < STAR_CHANCE && lum > 0.5,
          lum: lum
        });
      }
    }

    // Ordenar puntos por distancia desde el centro (más cercanos primero)
    dots.sort((a, b) => a.distance - b.distance);
  }

  function renderDots() {
    const w = canvas.width / DPR, h = canvas.height / DPR;
    
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Fondo negro + halo radial suave
    const rad = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, Math.max(w, h)/2);
    rad.addColorStop(0, "rgba(255,255,255,0.05)");
    rad.addColorStop(0.5, "rgba(255,255,255,0.02)");
    rad.addColorStop(1, "rgba(0,0,0,0)");
    ctx.fillStyle = rad; 
    ctx.fillRect(0, 0, w, h);

    // Calcular cuántos puntos mostrar basado en la animación
    const dotsToShow = Math.floor(dots.length * animationProgress);
    
    for (let i = 0; i < dotsToShow; i++) {
      const dot = dots[i];
      
      ctx.fillStyle = dot.color;
      ctx.beginPath();
      ctx.roundRect(dot.x, dot.y, 2, 2, 1);
      ctx.fill();

      // estrellitas puntuales
      if (dot.isStar) {
        ctx.save();
        ctx.globalAlpha = 0.9;
        ctx.fillStyle = "rgba(255,240,220,0.95)";
        ctx.fillRect(dot.x-1, dot.y-1, 3, 3);
        ctx.restore();
      }
    }
  }

  function animate() {
    animationProgress += 0.01; // Velocidad de la animación
    if (animationProgress >= 1) {
      animationProgress = 1;
      cancelAnimationFrame(animationId);
    } else {
      animationId = requestAnimationFrame(animate);
    }
    renderDots();
  }

  async function run() {
    resize();
    const img = await loadImage(SRC);
    const imgData = drawLogoToBuffer(img);
    generateDots(imgData);
    
    // Iniciar animación
    animationProgress = 0;
    if (animationId) cancelAnimationFrame(animationId);
    animate();
  }

  addEventListener("resize", run, { passive: true });
  setTimeout(run, 0);
</script>

<style>
  canvas { display:block; width:100%; height:100%; }
</style>
